"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var tls_1 = __importDefault(require("tls"));
var crypto_1 = require("crypto");
var utils_1 = require("./utils");
/**
 * A VNDB connection object. Uses a TLS Socket to provide the connection.
 */
var VNDBConnection = /** @class */ (function () {
    /**
     * Create a new connection object.
     */
    function VNDBConnection() {
        /** The TLS socket object */
        this.socket = undefined;
        this.eol = '\x04';
        this.id = crypto_1.randomBytes(12).toString('base64');
    }
    /**
     * Initialize a socket and connect it to the VNDB API
     * @param host VNDB API hostname
     * @param port VNDB API port (use the TLS port, not the TCP one)
     * @param encoding Type of encoding used
     * @return Resolves once the socket has connected to the server
     */
    VNDBConnection.prototype.connect = function (host, port, encoding) {
        var _this = this;
        if (encoding === void 0) { encoding = 'utf-8'; }
        return new Promise(function (resolve, reject) {
            _this.socket = tls_1.default.connect({ host: host, port: port }, function () {
                var _a, _b, _c;
                (_a = _this.socket) === null || _a === void 0 ? void 0 : _a.setEncoding(encoding);
                (_b = _this.socket) === null || _b === void 0 ? void 0 : _b.removeAllListeners('error');
                (_c = _this.socket) === null || _c === void 0 ? void 0 : _c.removeAllListeners('connect');
                resolve();
            });
            _this.socket.once('error', function (e) {
                _this.socket = undefined;
                reject(__assign(__assign({}, e), { message: 'Connection failed', status: 'error' }));
            });
        });
    };
    /**
     * Used to login to the API. It is required before sending further queries.
     * @param clientName A custom name for the client connecting to the API
     * @return Resolves once the API confirms the login
     */
    VNDBConnection.prototype.login = function (clientName) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _a, _b, _c;
            if (_this.socket == undefined) {
                reject({ code: 'NOTCONNECTED', message: 'Please connect first', status: 'error' });
            }
            (_a = _this.socket) === null || _a === void 0 ? void 0 : _a.once('error', function (e) {
                _this.disconnect();
                reject(e);
            });
            var chunk = '';
            (_b = _this.socket) === null || _b === void 0 ? void 0 : _b.on('data', function (data) {
                var _a, _b;
                chunk += data.toString();
                if (chunk.indexOf(_this.eol) == -1) {
                    // All data yet not recieved
                    return;
                }
                var response = chunk.substring(0, chunk.indexOf(_this.eol));
                if (response == 'ok') {
                    (_a = _this.socket) === null || _a === void 0 ? void 0 : _a.removeAllListeners('error');
                    (_b = _this.socket) === null || _b === void 0 ? void 0 : _b.removeAllListeners('data');
                    resolve();
                }
                else {
                    _this.disconnect();
                    reject(__assign(__assign({}, utils_1.errorParser(response)), { code: 'LOGINREJECT', status: 'error' }));
                }
            });
            (_c = _this.socket) === null || _c === void 0 ? void 0 : _c.write("login {\"protocol\":1,\"client\":\"" + clientName + "\",\"clientver\":1.0}" + _this.eol);
        });
    };
    /**
     * Used to end the connection.
     * @return Resolves once the connection is ended
     */
    VNDBConnection.prototype.disconnect = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var _a, _b;
            if (_this.socket == undefined) {
                resolve();
            }
            (_a = _this.socket) === null || _a === void 0 ? void 0 : _a.once('end', function () {
                _this.socket = undefined;
                resolve();
            });
            (_b = _this.socket) === null || _b === void 0 ? void 0 : _b.end();
        });
    };
    /**
     * Used to send a query to the VNDB API.
     * @param query A VNDB API compatible query string
     * @see {@link https://vndb.org/d11}
     * @return Resolves when the response is recieved
     */
    VNDBConnection.prototype.query = function (query) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _a, _b;
            // If not connected, error
            if (_this.socket == undefined) {
                reject({ code: 'NOTCONNECTED', message: 'Please connect first', status: 'error' });
            }
            // To join the data packets
            var chunk = '';
            // Actions to perform when data is recieved
            (_a = _this.socket) === null || _a === void 0 ? void 0 : _a.on('data', function (data) {
                var _a;
                chunk += data.toString();
                if (chunk.indexOf(_this.eol) == -1) {
                    // All data not yet recieved
                    return;
                }
                var response = chunk.substring(0, chunk.indexOf(_this.eol));
                (_a = _this.socket) === null || _a === void 0 ? void 0 : _a.removeAllListeners('data');
                response = utils_1.parseResponse(query, response);
                // handle errors
                if (response.status == 'error') {
                    var error = response;
                    if (error.id == 'throttled') {
                        utils_1.wait(error.fullwait * 1000).then(function () {
                            _this.query(query)
                                .then(function (delayedResponse) {
                                resolve(delayedResponse);
                            })
                                .catch(function (e) {
                                reject(e);
                            });
                        });
                    }
                    else {
                        reject(error);
                    }
                }
                else {
                    // if no error, then resolve
                    resolve(response);
                }
            });
            // Send the query
            (_b = _this.socket) === null || _b === void 0 ? void 0 : _b.write("" + query + _this.eol);
        });
    };
    return VNDBConnection;
}());
module.exports = VNDBConnection;
